% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpol.R
\name{interpol}
\alias{interpol}
\alias{interpol_res}
\title{Interpolate values to a grid using linear interpolation}
\usage{
interpol(.x, .y, .grid, .name = "ID", grow_grid = TRUE, ...)

interpol_res(
  .x,
  .y,
  .res,
  .name = "ID",
  grow_grid = TRUE,
  with_zero = TRUE,
  ...
)
}
\arguments{
\item{.x}{Vector of (observed) x, or independent values}

\item{.y}{Vector of (observed) y, or dependent values}

\item{.grid}{Vector of locations for calculated interpolated values.}

\item{.name}{An identifier added to the output dataframe, often useful
when this function is used in loops or with \code{map()} , \code{lapply()} or
their cousins.}

\item{grow_grid}{Should the output grid be extended to whole integer values
just above and just below the observed data (\code{interpol_res})? Should
interpolated values outside the source data be NA, or estimated as the
value at the closest data extreme (\code{interpol()})?
Useful for aligning data with whole number dates, depths, etc, which can
make interpolated graphics look a bit better.}

\item{...}{Further parameters to send to \code{approx()}. \code{na.rm = TRUE} is
perhaps the most likely.}

\item{.res}{Single numeric value representing output resolution in
units compatible with the \code{.x} variable.}

\item{with_zero}{Should the grid be expanded to include a value of zero?
Useful for interpolation along depths, in the common situation where
the shallowest observation is slightly below the surface, but a nice
graphic should start at depth == 0.}
}
\value{
A data frame with components \code{id} (arbitrary identifier, often useful
when output from these functions are fed directly into loops or used in
functional programming.), \code{ind} (independent variable), and \code{dep} (dependent
variable).
}
\description{
These functions are both a thin wrappers around the \code{approx()} function from
Base R's \code{stats} package. The primary difference is that these functions
output a tibble instead of list with \code{x} and \code{y} components. The
tibble / data frame output simplifies use in some work flows.
}
\details{
The functions uses simple linear interpolation to estimate values at
(generally unmeasured) locations between observed points.

The parameter names \code{.y}, \code{.x}, are mnemonics, to remind you that
the function will estimate the dependent variable \code{.y} at evenly spaced
intervals values along the .x direction, based on the (\code{.x}, \code{.y}) pairs
provided.

Ideas for this function and its use in profile graphics were inspired by
Dewey Dunnington's
fishandwhistle.net \href{https://fishandwhistle.net/post/2019/depth-time-heatmaps/}{blog}.
}
\section{Functions}{
\itemize{
\item \code{interpol}: Interpolate to values of a grid provided nu the user.
\code{interpol()} does nothing but check arguments, set useful defaults and
convert the output of \code{approx()} to a tibble.

\item \code{interpol_res}: Interpolation based on resolution.
\code{interpol_res()} is specialized for creating interpolated values at
regularly spaced intervals. It includes some optional parameters that
simplify its use in the context of creating smoothed depth-time plots from
repeated "profile" data, as often collected in limnology and oceanography.
The function is not directly used by other functions in this package, which
al lrely on \code{interpol()} instead.
}}

\examples{
data(dep_sonde)
dat <- dep_sonde[dep_sonde$month == 'Jul',]
grid <- seq(0, 14, 1)
interp <- interpol(dat$depth, dat$temp, .grid = grid)

ggplot(dat, aes(temp, depth)) +
  geom_point(size = 3, col = 'red') +
  geom_point(mapping = aes(dep, ind), data = interp, shape = 3) +
  scale_y_reverse()
data(dep_sonde)
dat <- dep_sonde[dep_sonde$month == 'Jul',]
interp <- interpol_res(dat$depth, dat$temp, .res = 0.5)

ggplot(dat, aes(temp, depth)) +
  geom_point(size = 3, col = 'red') +
  geom_point(mapping = aes(dep, ind), data = interp, shape = 3) +
  scale_y_reverse()
}
